"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.htmlEventAttributes = exports.isIsolatedScriptTag = exports.extractScriptTags = void 0;
const utils_1 = require("@astrojs/compiler/utils");
const language_core_1 = require("@volar/language-core");
const SourceMap = __importStar(require("@volar/source-map"));
const muggle = __importStar(require("muggle-string"));
function extractScriptTags(fileName, snapshot, htmlDocument, ast) {
    const embeddedJSFiles = [];
    for (const [index, root] of htmlDocument.roots.entries()) {
        if (root.tag === 'script' &&
            root.startTagEnd !== undefined &&
            root.endTagStart !== undefined &&
            isIsolatedScriptTag(root)) {
            const scriptText = snapshot.getText(root.startTagEnd, root.endTagStart);
            embeddedJSFiles.push({
                fileName: fileName + `.${index}.mts`,
                kind: language_core_1.FileKind.TypeScriptHostFile,
                snapshot: {
                    getText: (start, end) => scriptText.substring(start, end),
                    getLength: () => scriptText.length,
                    getChangeRange: () => undefined,
                },
                codegenStacks: [],
                mappings: [
                    {
                        sourceRange: [root.startTagEnd, root.endTagStart],
                        generatedRange: [0, scriptText.length],
                        data: language_core_1.FileRangeCapabilities.full,
                    },
                ],
                capabilities: {
                    diagnostic: true,
                    codeAction: true,
                    inlayHint: true,
                    documentSymbol: true,
                    foldingRange: true,
                    documentFormatting: false,
                },
                embeddedFiles: [],
            });
        }
    }
    const javascriptContexts = [
        ...findInlineScripts(htmlDocument, snapshot),
        ...findEventAttributes(ast),
    ].sort((a, b) => a.startOffset - b.startOffset);
    if (javascriptContexts.length > 0) {
        const codes = [];
        for (const javascriptContext of javascriptContexts) {
            codes.push([
                javascriptContext.content,
                undefined,
                javascriptContext.startOffset,
                language_core_1.FileRangeCapabilities.full,
            ]);
        }
        const mappings = SourceMap.buildMappings(codes);
        const text = muggle.toString(codes);
        embeddedJSFiles.push({
            fileName: fileName + '.inline.mjs',
            codegenStacks: [],
            snapshot: {
                getText: (start, end) => text.substring(start, end),
                getLength: () => text.length,
                getChangeRange: () => undefined,
            },
            capabilities: language_core_1.FileCapabilities.full,
            embeddedFiles: [],
            kind: language_core_1.FileKind.TypeScriptHostFile,
            mappings,
        });
    }
    return embeddedJSFiles;
}
exports.extractScriptTags = extractScriptTags;
function findInlineScripts(htmlDocument, snapshot) {
    const inlineScripts = [];
    for (const [_, root] of htmlDocument.roots.entries()) {
        if (root.tag === 'script' &&
            root.startTagEnd !== undefined &&
            root.endTagStart !== undefined &&
            !isIsolatedScriptTag(root)) {
            const scriptText = snapshot.getText(root.startTagEnd, root.endTagStart);
            inlineScripts.push({
                startOffset: root.startTagEnd,
                content: scriptText,
            });
        }
    }
    return inlineScripts;
}
function findEventAttributes(ast) {
    const eventAttrs = [];
    // `@astrojs/compiler`'s `walk` method is async, so we can't use it here. Arf
    function walkDown(parent) {
        if (!parent.children)
            return;
        parent.children.forEach((child) => {
            if (utils_1.is.element(child)) {
                const eventAttribute = child.attributes.find((attr) => exports.htmlEventAttributes.includes(attr.name) && attr.kind === 'quoted');
                if (eventAttribute && eventAttribute.position) {
                    eventAttrs.push({
                        content: eventAttribute.value,
                        startOffset: eventAttribute.position.start.offset + `${eventAttribute.name}="`.length,
                    });
                }
            }
            if (utils_1.is.parent(child)) {
                walkDown(child);
            }
        });
    }
    walkDown(ast);
    return eventAttrs;
}
function isIsolatedScriptTag(scriptTag) {
    // Using any kind of attributes on the script tag will disable hoisting
    if (!scriptTag.attributes ||
        (scriptTag.attributes && Object.entries(scriptTag.attributes).length === 0) ||
        scriptTag.attributes['type']?.includes('module')) {
        return true;
    }
    return false;
}
exports.isIsolatedScriptTag = isIsolatedScriptTag;
exports.htmlEventAttributes = [
    'onabort',
    'onafterprint',
    'onauxclick',
    'onbeforematch',
    'onbeforeprint',
    'onbeforeunload',
    'onblur',
    'oncancel',
    'oncanplay',
    'oncanplaythrough',
    'onchange',
    'onclick',
    'onclose',
    'oncontextlost',
    'oncontextmenu',
    'oncontextrestored',
    'oncopy',
    'oncuechange',
    'oncut',
    'ondblclick',
    'ondrag',
    'ondragend',
    'ondragenter',
    'ondragleave',
    'ondragover',
    'ondragstart',
    'ondrop',
    'ondurationchange',
    'onemptied',
    'onended',
    'onerror',
    'onfocus',
    'onformdata',
    'onhashchange',
    'oninput',
    'oninvalid',
    'onkeydown',
    'onkeypress',
    'onkeyup',
    'onlanguagechange',
    'onload',
    'onloadeddata',
    'onloadedmetadata',
    'onloadstart',
    'onmessage',
    'onmessageerror',
    'onmousedown',
    'onmouseenter',
    'onmouseleave',
    'onmousemove',
    'onmouseout',
    'onmouseover',
    'onmouseup',
    'onoffline',
    'ononline',
    'onpagehide',
    'onpageshow',
    'onpaste',
    'onpause',
    'onplay',
    'onplaying',
    'onpopstate',
    'onprogress',
    'onratechange',
    'onrejectionhandled',
    'onreset',
    'onresize',
    'onscroll',
    'onscrollend',
    'onsecuritypolicyviolation',
    'onseeked',
    'onseeking',
    'onselect',
    'onslotchange',
    'onstalled',
    'onstorage',
    'onsubmit',
    'onsuspend',
    'ontimeupdate',
    'ontoggle',
    'onunhandledrejection',
    'onunload',
    'onvolumechange',
    'onwaiting',
    'onwheel',
];
//# sourceMappingURL=parseJS.js.map