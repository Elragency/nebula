"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = (options = {}, getPrettierConfig = async (prettier, config) => {
    const configFile = await prettier.resolveConfigFile();
    if (configFile) {
        return await prettier.resolveConfig(configFile, config) ?? {};
    }
    return {};
}) => (context) => {
    if (!context) {
        return {};
    }
    let prettier;
    try {
        prettier = options.prettier ?? require('prettier');
    }
    catch (e) {
        throw new Error("Could not load Prettier: " + e);
    }
    const languages = options.languages ?? ['html', 'css', 'scss', 'typescript', 'javascript'];
    return {
        async provideDocumentFormattingEdits(document, _, formatOptions) {
            if (!languages.includes(document.languageId)) {
                return;
            }
            const filePrettierOptions = await getPrettierConfig(prettier, options.resolveConfigOptions);
            const fileInfo = await prettier.getFileInfo(context.env.uriToFileName(document.uri), { ignorePath: '.prettierignore' });
            if (fileInfo.ignored) {
                return;
            }
            const editorPrettierOptions = await context.env.getConfiguration?.('prettier', document.uri);
            const ideFormattingOptions = formatOptions !== undefined && options.useIdeOptionsFallback // We need to check for options existing here because some editors might not have it
                ? {
                    tabWidth: formatOptions.tabSize,
                    useTabs: !formatOptions.insertSpaces,
                }
                : {};
            const fullText = document.getText();
            let oldText = fullText;
            const isHTML = document.languageId === 'html';
            if (isHTML && options.html?.breakContentsFromTags) {
                oldText = oldText
                    .replace(/(<[a-z][^>]*>)([^ \n])/gi, '$1 $2')
                    .replace(/([^ \n])(<\/[a-z][a-z0-9\t\n\r -]*>)/gi, '$1 $2');
            }
            // Return a config with the following cascade:
            // - Prettier config file should always win if it exists, if it doesn't:
            // - Prettier config from the VS Code extension is used, if it doesn't exist:
            // - Use the editor's basic configuration settings
            const prettierOptions = returnObjectIfHasKeys(filePrettierOptions) || returnObjectIfHasKeys(editorPrettierOptions) || ideFormattingOptions;
            const currentPrettierConfig = {
                ...options.additionalOptions ? await options.additionalOptions(prettierOptions) : prettierOptions,
                filepath: context.env.uriToFileName(document.uri),
            };
            if (!options.ignoreIdeOptions) {
                currentPrettierConfig.useTabs = !formatOptions.insertSpaces;
                currentPrettierConfig.tabWidth = formatOptions.tabSize;
            }
            return [{
                    newText: await prettier.format(oldText, currentPrettierConfig),
                    range: {
                        start: document.positionAt(0),
                        end: document.positionAt(fullText.length),
                    },
                }];
        },
    };
};
function returnObjectIfHasKeys(obj) {
    if (Object.keys(obj || {}).length > 0) {
        return obj;
    }
}
//# sourceMappingURL=index.js.map